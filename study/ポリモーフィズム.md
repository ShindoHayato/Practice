# Java

### ポリモーフィズム
ポリモーフィズムとは多態性のことで、異なる処理を持つオブジェクトを同一の操作で扱うことができることを指す。  
(同じ型で異なるクラスのオブジェクトを扱うことができる。広義ではオーバーロードも含む)

オブジェクト同士の共通点を見つけ抽象化することで、コードの簡略化と可読性の向上を図ることができる。

### ポリモーフィズムの利点
```
# 柔軟性
同じインターフェースや親クラス型を使用して、異なる子クラスのオブジェクトを統一的に扱えます。
具体的なクラスに依存せず、柔軟な設計が可能になります。

# コードの再利用性:
共通の振る舞いは親クラスやインターフェースに定義し、子クラスで差分や具体的な実装を行うことで、
コードの重複を避けることができます。

# 拡張性:
新しい子クラスを追加するだけで、既存のコードを変更せずに新しい振る舞いを追加できます。
```

### インターフェースの定義
```java
interface MyInterface {
    // 定数
    int CONSTANT = 100; // public static final が自動的に付与される
    // 抽象メソッド
    void method1(); // public abstract が自動的に付与される
    void method2();
}
```

### 抽象クラスの定義
```java
abstract class MyAbstractClass {
    // フィールド
    private int field;

    // コンストラクタ
    public MyAbstractClass(int field) {
        this.field = field;
    }

    // 抽象メソッド
    abstract void abstractMethod(); // サブクラスで実装する必要がある

    // 通常のメソッド
    void normalMethod() {
        System.out.println("Normal method");
    }
}
```

※ インターフェースは複数『実装』が可能 / 継承は1つのクラスのみ可能

### 例: 動物のクラスを使ったポリモーフィズム
```java
// 抽象クラス
abstract class Animal {
    abstract void makeSound(); // 抽象メソッド（具体的な実装はサブクラスで行う）
    void sleep() {
        System.out.println("Sleeping...");
    }
}

// サブクラス
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}
class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow!");
    }
}

public class Polymorphism {
    public static void main(String[] args) {
        Animal myDog = new Dog(); // ポリモーフィズム: スーパークラス型でサブクラスを参照
        Animal myCat = new Cat();

        myDog.makeSound(); // 出力: Woof!
        myCat.makeSound(); // 出力: Meow!
        
        myDog.sleep(); // 共通メソッドの呼び出し
        
        testPolymorphism(myDog); // 引数にAnimal型を指定
        
        List<Animal> animals = new ArrayList<>();
        animals.add(myDog);
        animals.add(myCat);
        // 新しい動物を追加するだけで、既存のコードを変更せずに済む
        for (Animal animal : animals) {
            animal.makeSound(); // 各動物の鳴き声を出力
        }
    }
    
    private static void testPolymorphism(Animal animal) {
        animal.makeSound(); // Animal型の引数を受け取るメソッド
    }
}

// ポリモーフィズムを使わない場合
public class MainWithoutPolymorphism {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        Cat myCat = new Cat();

        List<Object> animals = new ArrayList<>();
        animals.add(myDog);
        animals.add(myCat);
        for (Object animal : animals) {
            // 新しい動物を追加するたびに、if文を追加する必要がある　OCP(Open/Closed Principle)違反
            if (animal instanceof Dog) {
                ((Dog) animal).makeSound(); // Dog型にキャストしてメソッドを呼び出す
            } else if (animal instanceof Cat) {
                ((Cat) animal).makeSound(); // Cat型にキャストしてメソッドを呼び出す
            }
        }
    }
}
```

### 広義のポリモーフィズム
オーバーロードを利用したポリモーフィズム
``` 
System.out.println("Hello, World!"); // String型の引数
System.out.println(100); // int型
System.out.println(3.14); // double型
System.out.println(true); // boolean型
```

https://docs.oracle.com/javase/jp/17/docs/api/java.base/java/io/PrintStream.html
