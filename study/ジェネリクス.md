# ジェネリクス

Javaのジェネリクス（Generics、総称型)とは、クラスやインターフェース、
メソッドで扱うデータの型をパラメータ（型引数）として定義できる機能です

これにより、例えばクラスやメソッドを`<T>`といった記号で型の汎用パラメータとして宣言し、汎用的なクラスやメソッドを作成できます。  
実際に使うときに Integer や String など具体的な型を指定して利用できます
```java
// ジェネリクスを使ったインターフェイス
interface GenericsInterface<T> {
    void doSomething(T t);
}

// ジェネリクスを使ったクラス
class GenericsClass<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

// ジェネリクスを使ったメソッド
class GenericsMethod {
    public static <T> void print(T t) {
        System.out.println(t);
    }
}

// 使用例
public class Main {
    public static void main(String[] args) {
        // GenericsClassのインスタンスを作成
        GenericsClass<String> stringInstance = new GenericsClass<>();
        stringInstance.setValue("Hello, Generics!");
        System.out.println(stringInstance.getValue());

        // GenericsMethodを使用
        GenericsMethod.print(123);
        GenericsMethod.print("Hello, World!");
    }
}
```

型パラメータの命名規則は一般的に以下のように使われます

- T: 型パラメータ ※Tと併用でU,Vなども順に使われる
- E: 要素の型（コレクションなど）
- K: キーの型（マップなど）
- V: 値の型（マップなど）
- N: 数値型

----

Java5以前はジェネリクスがなく、コレクションにはObject型を使っていました。  
以下の例では型安全性が保証されていないため、実行時にClassCastExceptionが発生する可能性があります
```java
// 原型Listを使用 Object型
List list = new ArrayList();
list.add("Alice");
// キャストが必要
// ※ キャストは基本利用しない
String name = (String) list.get(0);

// String型以外の要素を追加できてしまう
list.add(100);
// ClassCastExceptionが発生する
String score = (String) list.get(1);
```

ジェネリクスを使うと、コンパイル時に型安全性を保証できます
```java
List<String> list = new ArrayList<>();
list.add("Alice");

// キャストが不要
String name = list.get(0);

// String型以外の要素を追加できない
// コンパイルエラー
list.add(100);
```

ワイルドカードと境界付き型パラメータ

```java
class ClassSample<T> {
    private T data;

    public ClassSample(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```
上限境界ワイルドカード（? extends T）
```java
ClassSample<Integer> csInt = new ClassSample<>(100);

// 上限境界ワイルドカードを使って受け取る（NumberかそのサブクラスならOK）
ClassSample<? extends Number> csNum;
csNum = csInt;                      // IntegerはNumberのサブクラスなので代入可能

Number x = csNum.getData();         // 取り出したデータはNumber型として扱える
System.out.println(x);              // 出力: 100
// csNum.setData(...) は許可されない（コンパイルエラー）

// TはNumberのサブクラスに限定される。IntegerやDoubleなどのサブクラスは許可されるが、Stringなどは許可されない
public class GenericsClass<T extends Number> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```
下限境界ワイルドカード（? super T）
```java
ClassSample<Number> csNum = new ClassSample<>(3.14);

// 下限境界ワイルドカードを使って受け取る（IntegerかそのスーパータイプならOK）
ClassSample<? super Integer> csSuper;
csSuper = csNum;                    // NumberはIntegerのスーパータイプなので代入可能

Object obj = csSuper.getData();     // 取り出したデータはObject型として扱う（Numberとしても良いがIntegerとは限らない）
System.out.println(obj);            // 出力: 3.14
csSuper = new ClassSample<Number>(42);
csSuper = new ClassSample<Object>("abc");  // ObjectはIntegerのスーパータイプなのでOK

// csSuperにIntegerを追加するメソッドがあれば、それは実行可能（実際の例ではsetDataがあればIntegerを渡せる）

// クラス定義でsuperを使うことはできない
// public class GenericsClass<T super Number> {}
```

再帰型境界
```java
public class GenericsUtil {
    public static <T extends Comparable<T>> T max(List<T> list) {
        if (list == null || list.isEmpty()) throw new IllegalArgumentException();

        T max = list.get(0);
        for (T item : list) {
            if (item.compareTo(max) > 0) {
                max = item;
            }
        }
        return max;
    }
}

List<Integer> nums = List.of(3, 7, 2, 9);
Integer maxInt = GenericsUtil.max(nums); // 9

List<String> names = List.of("apple", "banana", "orange");
String maxStr = GenericsUtil.max(names); // "orange"（辞書順）
```

複数境界
```java
public class GenericsUtil {
    public static <T extends Number & Comparable<T>> T max(List<T> list) {
        if (list == null || list.isEmpty()) throw new IllegalArgumentException();

        T max = list.get(0);
        for (T item : list) {
            if (item.compareTo(max) > 0) {
                max = item;
            }
        }
        return max;
    }
}
```

ジェネリクスの型パラメータは、クラスやメソッドの定義時に指定されるもので、実行時には具体的な型に置き換えられます。
ただし、Javaの型消去（Type Erasure）により、実行時には型パラメータは消失します


PECS（Producer Extends, Consumer Super）という覚え方があります
`<? extends T>` は「生産者」であり、`<? super T>` は「消費者」です

`<? extends T>`型のデータを取得する際はT型として扱うことができるが、データ追加の際は型が不明となるためコンパイルエラーとなります
`<? super T>`型のデータを取得する際はObject型として扱うことになる。データ追加の際はT型として扱うことができるため、コンパイルエラーとはなりません


より詳しくはEffective Javaを参照
※　中級者以上向けの難しい書籍です
https://www.maruzen-publishing.co.jp/item/b303408.html
