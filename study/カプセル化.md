# カプセル化

カプセル化とはクラスのフィールドを直接操作せずに、メソッドを介してのみアクセスさせること

```java
public class Person {
    // フィールドはprivateにする
    private String name;

    // コンストラクタ
    public Person(String name) {
        this.name = name;
    }

    // ゲッター
    public String getName() {
        return name;
    }

    // セッター
    public void setName(String name) {
        this.name = name;
    }
}
```

アクセス修飾子
- public: クラス、メソッド、フィールドがどこからでもアクセス可能
- protected: 同じパッケージ内またはサブクラスからアクセス可能
- private: 同じクラス内からのみアクセス可能
- なし：同じパッケージ内からのみアクセス可能

重要ポイント
- privateにできるものはprivateにする
- final修飾子を使い、値を変更できないようにする
- オブジェクトは不変(immutable)であるべきなので、セッターメソッドは用意しない
  - コンストラクタで初期化する
  - 変更する際は、新しいオブジェクトを作成する
  - ListやMapもCollections.unmodifiableList()やCollections.unmodifiableMap()を使うことで中身を不変にできる
  - Java 9以降はList.of()やMap.of()を使うことで不変のコレクションを作成できる
  - ライブラリを使うことで、用意されているImmutableListやImmutableMapなどの不変コレクションを使うこともできる
    ```
    /**
    *  タスク名とタグ一覧を持つ Taskクラス
    */
    public final class Task {

        private final String title;
        private final List<String> tags;

        /**
        * コンストラクタでのみ初期化
        * @param title タスク名
        * @param tags  初期タグリスト
        */
        public Task(String title, List<String> tags) {
            this.title = title;
            // 防御的コピー＆不変リスト化
            this.tags = Collections.unmodifiableList(new ArrayList<>(tags));
        }

        /**
        * 新しいタグを追加した新インスタンスを生成して返す
        * 既存のこのオブジェクトは変わらない
        */
        public Task addTag(String tag) {
            List<String> newTags = new ArrayList<>(tags);
            newTags.add(tag);
            return new Task(title, newTags);
        }
    }
    ```
