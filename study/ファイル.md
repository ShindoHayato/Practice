# Java

Javaでは特定のクラスを使用して、ファイルの入力や出力が可能になります。 

Javaの入出力は**ストリーム**という仕組みを介して行われるのが基本です。
ストリームはデータの受け渡しを抽象化したもので、データの流れを表現します。

ストリームを流れるデータは２つの種類に分けられます。
- バイトストリーム
- 文字ストリーム


```mermaid
flowchart RL
  subgraph ファイル
    File[ファイル]
  end

  subgraph ストリーム
    OutputStream[出力ストリーム]
  end

  subgraph アプリケーション
    WriteApp[書き込み]
  end

  WriteApp --> OutputStream --> File
```

```mermaid
flowchart LR
  subgraph 入出力
    StdIO[標準入出力]
  end
  
  subgraph ストリーム
    InputStream[入力ストリーム]
  end
  
  subgraph　アプリケーション
    ReadApp[読み込み]
  end
  
  StdIO --> InputStream --> ReadApp
```

<br>

### 重要な抽象クラス
- **InputStream**: バイトストリームの基底クラス
- **OutputStream**: バイトストリームの基底クラス
- **Reader**: 文字ストリームの基底クラス
- **Writer**: 文字ストリームの基底クラス


### ファイルの読み書き 
ファイルを読み込む場合、Javaでは以下のクラスを使用することが一般的です。
- **FileReader**: 文字ストリームを使用してファイルを読み込む
- **FileInputStream**: バイトストリームを使用してファイルを読み込む(画像など)
- **FileWriter**: 文字ストリームを使用してファイルに書き込む
- F**ileOutputStream**: バイトストリームを使用してファイルに書き込む(画像など)

基本的には下記のBufferedReaderやBufferedInputStreamなどと組み合わせて使用します。
- **BufferedInputStream**: FileInputStreamと組み合わせて使用することで、効率的にファイルを読み込むことができる
- **BufferedReader**: FileReaderと組み合わせて使用することで、効率的にファイルを読み込むことができる
- **BufferedOutputStream**: FileOutputStreamと組み合わせて使用することで、効率的にファイルに書き込むことができる
- **BufferedWriter**: FileWriterと組み合わせて使用することで、効率的にファイルに書き込むことができる

```
// try-with-resources文を使用して、リソースを自動的に閉じる
// AutoCloseableインターフェースを実装しているクラスは、try-with-resources文で自動的に閉じることができる

// BufferedReaderを使用してファイルを読み込む
try (BufferedReader br = new BufferedReader(new FileReader("example.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        // 1行ずつ出力
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}

// BufferedInputStreamを使用してファイルを読み込む
try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("example.txt"))) {
    int content;
    while ((content = bis.read()) != -1) {
        // バイトデータをそのまま処理
        System.out.print((char) content);
    }
} catch (IOException e) {
    e.printStackTrace();
}

// BufferedWriterを使用してファイルに書き込む
try (BufferedWriter bw = new BufferedWriter(new FileWriter("example.txt"))) {
    // ファイルに書き込む
    bw.write("Hello, World!");
} catch (IOException e) {
    e.printStackTrace();
}

// BufferedOutputStreamを使用してファイルに書き込む
try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("example.txt"))) {
    // バイトデータを書き込む
    bos.write(new byte[]{65, 66, 67}); // A, B, C
} catch (IOException e) {
    e.printStackTrace();
}
```

<br>

### Files
ファイルを扱うためのユーティリティクラスです

Filesを使うことで簡潔にファイルの読み書きが可能になります。

https://docs.oracle.com/javase/jp/17/docs/api/java.base/java/nio/file/Files.html

```
// ファイル内容を読み込む
String content = Files.readString(Path.of(filePath));

// ファイルに書き込む APPENDオプションを指定することで、追記することができる
Files.writeString(Path.of(filePath), content, StandardOpenOption.APPEND);

// ファイルをコピーする
Files.copy(Path.of(sourcePath), Path.of(destinationPath), StandardCopyOption.REPLACE_EXISTING);

// BufferedReaderを使用してファイルを読み込む
BufferedReader br = Files.newBufferedReader(Path.of(filePath))

// BufferedWriterを使用してファイルに書き込む
BufferedWriter bw = Files.newBufferedWriter(Path.of(filePath))
```

### Path
ファイルのパスを扱うためのクラスです

File関連ではセットで使用することが多いです

```java
// ファイルのパスを取得する
// デフォルトのファイルシステムを使用して、ファイルのパスを取得する
Path path = Path.of("." + File.separator + dir + File.separator + fileName);

// PathをFileに変換する
File file = path.toFile();
```

※ Pathsは今後のJavaで非推奨になる可能性がある
https://docs.oracle.com/javase/jp/17/docs/api/java.base/java/nio/file/Paths.html

### 注意点
- ファイルのクローズ処理を忘れずに行うことが重要
- パスの区切り文字はFile.separatorなどの用意された定数を使用すること
