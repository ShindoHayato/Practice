# データベース設定

SpringBootではデータベースとのやりとりを簡単に行うための機能が提供されています。  
ライブラリの依存を追加し、設定ファイル(application.yml)に接続情報を記述することで、データベースとの接続が可能になります。

ライブラリとしては主に3種類 ※ORM(Object Relation Mapper)と呼ばれます
- **JDBC**: Java Database Connectivityの略。JavaからデータベースにアクセスするためのAPI。
```java
@RequiredArgsConstructor
@Repository
public class UserRepository {

    private final JdbcTemplate jdbc;
    
    // RowMapper をラムダで定義
    private final RowMapper<User> userMapper = (rs, rowNum) -> {
        User u = new User();
        u.setId(rs.getLong("id"));
        u.setName(rs.getString("name"));
        u.setEmail(rs.getString("email"));
        return u;
    };

    public List<User> findAll() {
        String sql = "SELECT id, name, email FROM users";
        return jdbc.query(sql, userMapper);
    }
}

// マッピングする方法
public interface UserRepository extends CrudRepository<User, Long> {
    // 基本的なCRUD操作はCrudRepositoryが提供する
    // save, findById, findAll, deleteById など
    
    @Query("SELECT u FROM User u WHERE u.name = :name")
    List<User> findByName(@Param("name") String name);
}

@Table("users")
public class User {
    @Id
    private Long id;

    private String name;
    private String email;

    // コンストラクタ／ゲッター・セッター省略
}

// Joinを含むマッピングはカバーしていないため、結果をDTO(受け取り用のクラス)で受け取る必要がある
```

- **JPA**: Java Persistence APIの略。オブジェクトとリレーショナルデータベースのマッピングを行うためのAPI。
```java
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    // 基本的なCRUD操作はJpaRepositoryが提供する
    // save, findById, findAll, deleteById など

    // 顧客と、その顧客の注文を一括フェッチ
    @Query("""
            SELECT c FROM Customer c
            JOIN FETCH c.orders o
            WHERE c.id = :id
            """)
    Optional<Customer> findByIdWithOrders(@Param("id") Long id);
}

@Entity
@Table(name = "customers")
public class Customer {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    // 双方向 OneToMany (Lazy)：Customer → Order
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Order> orders = new ArrayList<>();

    // コンストラクタ／ゲッター・セッター省略
}

// アノテーションでJOIN含むマッピングが可能
// SQLの記述は不要で、JPAが自動的に生成する。クエリが自動生成のため、調査は大変
```

- **MyBatis**: SQLを直接記述し、マッピングを行うフレームワーク。JPAよりもSQLに近い操作が可能。

```java
@Mapper
public interface UserMapper {
    // 全ユーザー＋ロール情報を取得
    List<User> findAllWithRole();

    // ID 指定で取得
    User findByIdWithRole(@Param("id") Long id);

    // 通常の INSERT（自動生成キー取得）
    int insert(User user);

    // update, delete なども同様に定義可能
}
```
基本的にはxmlでマッピングを定義する
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.mapper.UserMapper">

    <!-- resultMap を定義して User.role をマッピング -->
    <resultMap id="UserWithRole" type="com.example.demo.model.User">
        <id property="id" column="user_id"/>
        <result property="username" column="username"/>
        <result property="email" column="email"/>
        <association property="role" javaType="com.example.demo.model.Role">
            <id property="id" column="role_id"/>
            <result property="name" column="role_name"/>
        </association>
    </resultMap>

    <!-- JOIN を含む全件取得 -->
    <select id="findAllWithRole" resultMap="UserWithRole">
        SELECT
        u.id   AS user_id,
        u.username,
        u.email,
        r.id   AS role_id,
        r.name AS role_name
        FROM users u
        LEFT JOIN roles r ON u.role_id = r.id
    </select>

    <!-- JOIN を含む単一取得 -->
    <select id="findByIdWithRole" parameterType="long" resultMap="UserWithRole">
        SELECT
        u.id   AS user_id,
        u.username,
        u.email,
        r.id   AS role_id,
        r.name AS role_name
        FROM users u
        LEFT JOIN roles r ON u.role_id = r.id
        WHERE u.id = #{id}
    </select>

    <!-- INSERT は自動生成キーを取得 -->
    <insert id="insert" parameterType="com.example.demo.model.User" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO users(username, email, role_id)
        VALUES (#{username}, #{email}, #{role.id})
    </insert>

</mapper>

```

### データベース設定
```yaml
# 共通設定（すべての方式で必要）
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/sampledb
    username: dbuser
    password: dbpass
    driver-class-name: org.postgresql.Driver
  sql:
    init:
      schema-locations: classpath:/sql/schema.sql
      data-locations: classpath:/sql/data.sql
      mode: embedded
      encoding: UTF-8
---

# 1. JDBC（JdbcTemplate）を使う場合
# → SQLを直書きしてフルコントロールしたいケース向け
spring:
  jdbc:
    template:
      # JDBCテンプレートの設定
      fetch-size: 1000    # フェッチサイズ
      max-rows: 10000     # 最大行数
---

# 2. JPA（Spring Data JPA + Hibernate）を使う場合
# → エンティティ駆動で開発生産性を優先するとき
spring:
  jpa:
    hibernate:
      ddl-auto: update    # none | validate | update | create | create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 50    # バルクインサート時のバッチサイズ
        order_inserts: true
        order_updates: true
---

# 3. MyBatis（XML Mapper）を使う場合
# → SQL最適化＋マッピング自動化のバランスを取りたいとき
mybatis:
  # Mapper XML の配置場所（classpathベース）
  mapper-locations: classpath:/mappers/**/*.xml
  # SQL ログを詳細に出す設定
  configuration:
    map-underscore-to-camel-case: true    # スネークケース → キャメルケース自動変換
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  type-aliases-package: com.example.demo.model
```

ローカルではH2というインメモリデータベースを使うことが多いですが、
springbootでは簡単な設定ですぐ利用することができます

1. H2の依存を追加
2. application.ymlに設定を追加
```yaml
# H2データベースの設定
spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=MySQL
    driver-class-name: org.h2.Driver
    username: user
    password: pass
  h2:
    console:
      path: /h2-console
      enabled: true
```
