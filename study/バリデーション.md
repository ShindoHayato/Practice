# バリデーション

バリデーションとは入力値の検証を行うことです。

Spring Bootではアノテーションを使用して、バリデーションを行うことができます。

- `@Valid`: バリデーションのターゲットを指定します。また、ネストしたオブジェクトのバリデーション実施時にフィールドに対して付与する
- `@Validated`: `@Valid`と同様ですが、グループ化されたバリデーションも行うことができます。


- `@NotNull`: 値が`null`でないことを検証します。
- `@NotEmpty`: 値が空でないことを検証します。
- `@Size`: 値のサイズを検証します。
- `@Min`: 最小値を検証します。
- `@Max`: 最大値を検証します。
- `@Pattern`: 正規表現にマッチすることを検証します。

また、`@Valid`と`@Validated`でのバリデーション検証エラーで発生する例外は異なります
- `@Valid`は`MethodArgumentNotValidException`
- `@Validated`は`ConstraintViolationException`をスローします。

※ 上記を例外ハンドリングクラスでキャッチし、エラー詳細は例外クラスから取得できます。

```java
public class UserRequest {
    @NotBlank(message = "名前は必須です")
    @Size(max = 20, message = "名前は20文字以内で入力してください")
    private String name;

    @NotBlank(message = "メールアドレスは必須です")
    @Email(message = "メールアドレスの形式が正しくありません")
    private String email;

    @Min(value = 0, message = "年齢は0以上で入力してください")
    @Max(value = 120, message = "年齢は120以下で入力してください")
    private Integer age;
}
```
BindingResultを使用して、バリデーションエラーをハンドリング
```java
@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping
    public ResponseEntity<?> registerUser(@Validated @RequestBody UserRequest userRequest, BindingResult bindingResult) {
        if (bindingResult.hasErrors()) {
            // バリデーションエラー時はエラーメッセージを返却
            return ResponseEntity.badRequest().body(bindingResult.getAllErrors());
        }
        // 正常処理
        return ResponseEntity.ok("ユーザー登録成功");
    }
}
```

グループ化
```java
public class UserRequest {
    @NotBlank(message = "名前は必須", groups = {Create.class, Update.class})
    private String name;

    @NotBlank(message = "パスワードは必須", groups = Create.class)
    private String password;
}

@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping
    public ResponseEntity<?> create(@Validated(Create.class) @RequestBody UserRequest req, BindingResult br) {
        if (br.hasErrors()) { /* エラー処理 */ }
        return ResponseEntity.ok("登録成功");
    }

    @PutMapping
    public ResponseEntity<?> update(@Validated(Update.class) @RequestBody UserRequest req, BindingResult br) {
        if (br.hasErrors()) { /* エラー処理 */ }
        return ResponseEntity.ok("更新成功");
    }
}
```
Controllerクラスに付与する例
```java
@Validated  // ←クラスにつける
@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping
    public String createUser(@RequestBody @Valid UserRequest req) {
        return "OK";
    }

    // 下記のような「メソッド引数の値」バリデーションも有効
    @GetMapping("/{id}")
    public String getUser(
        @PathVariable @Min(1) Long id  // ←ここもバリデーションされる
    ) {
        return "OK";
    }
}
```
BindingResultを使用せず、ExceptionHandlerを用意する場合の例
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleMethodArgumentNotValid(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errors = new ArrayList<>();
        for (FieldError fieldError : ex.getBindingResult().getFieldErrors()) {
            Map<String, String> error = new HashMap<>();
            error.put("field", fieldError.getField());
            error.put("message", fieldError.getDefaultMessage());
            errors.add(error);
        }
        // エラー一覧をJSONで返す
        return ResponseEntity.badRequest().body(errors);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<?> handleConstraintViolation(ConstraintViolationException ex) {
        List<Map<String, String>> errors = new ArrayList<>();
        ex.getConstraintViolations().forEach(violation -> {
            Map<String, String> error = new HashMap<>();
            // プロパティパス（どのパラメータか）
            error.put("field", violation.getPropertyPath().toString());
            // エラーメッセージ
            error.put("message", violation.getMessage());
            errors.add(error);
        });
        return ResponseEntity.badRequest().body(errors);
    } 
}
```
